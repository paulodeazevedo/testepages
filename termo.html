<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Termo Customizado Ilimitado</title>
    <style>
        :root {
            --cor-fundo: #121213;
            --cor-tecla: #818384;
            --cor-letra: #d7dadc;
            --cor-letra-presente: #b59f3b;
            /* Amarelo */
            --cor-letra-correta: #538d4e;
            /* Verde */
            --cor-letra-errada: #3a3a3c;
            /* Cinza Escuro */
            --cor-borda: #3a3a3c;
            --altura-teclado: 200px;
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
            background-color: var(--cor-fundo);
            color: var(--cor-letra);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: var(--altura-teclado);
            margin: 0;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            margin: 10px 0;
            width: 100%;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--cor-borda);
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            letter-spacing: 0.1em;
        }

        .tabuleiro-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 10px 0;
            width: 100%;
        }

        .tabuleiro {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            grid-gap: 5px;
        }

        .linha {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: 5px;
        }

        .celula {
            width: 50px;
            height: 50px;
            border: 2px solid var(--cor-borda);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            font-weight: bold;
            text-transform: uppercase;
            transition: background-color 0.5s ease-in-out, border-color 0.1s ease;
            user-select: none;
            cursor: pointer;
        }

        /* Cor da c√©lula selecionada/ativa */
        .celula.ativa {
            border-color: var(--cor-letra);
        }

        .celula.preenchida {
            border-color: var(--cor-letra-errada);
        }

        .celula.correta {
            background-color: var(--cor-letra-correta);
            border-color: var(--cor-letra-correta);
            color: white;
            cursor: default;
        }

        .celula.presente {
            background-color: var(--cor-letra-presente);
            border-color: var(--cor-letra-presente);
            color: white;
            cursor: default;
        }

        .celula.errada {
            background-color: var(--cor-letra-errada);
            border-color: var(--cor-letra-errada);
            color: white;
            cursor: default;
        }

        /* --- TECLADO FIXO PARA MOBILE --- */
        .teclado-fixed {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--altura-teclado);
            background-color: var(--cor-fundo);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            box-sizing: border-box;
            border-top: 1px solid var(--cor-borda);
            z-index: 1000;
        }

        .linha-teclado {
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
            width: 100%;
        }

        .tecla {
            background-color: var(--cor-tecla);
            color: var(--cor-letra);
            font-size: 0.9em;
            font-weight: bold;
            padding: 15px 0;
            margin: 0 3px;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            flex-grow: 1;
            text-align: center;
            text-transform: uppercase;
            transition: background-color 0.1s;
            min-width: 20px;
        }

        .tecla.tecla-entrar,
        .tecla.tecla-apagar {
            flex-grow: 1.5;
            font-size: 0.7em;
            padding: 15px 5px;
        }

        .tecla.errada {
            background-color: var(--cor-letra-errada);
            color: white;
        }

        .tecla.presente {
            background-color: var(--cor-letra-presente);
            color: white;
        }

        .tecla.correta {
            background-color: var(--cor-letra-correta);
            color: white;
        }

        /* Controles Adicionais */
        .controles {
            width: 100%;
            max-width: 500px;
            margin: 10px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: #1f1f1f;
            border-radius: 8px;
            box-sizing: border-box;
        }

        .controles-linha-1 {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .controles-linha-2 {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .controles button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            flex-grow: 1;
        }

        .controles button.primary {
            background-color: #007bff;
            color: white;
        }

        .controles button:hover {
            background-color: #0056b3;
        }

        .controles input[type="number"] {
            background-color: #3a3a3c;
            color: var(--cor-letra);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--cor-borda);
            width: 80px;
            text-align: center;
        }

        #currentId {
            font-weight: bold;
            color: #007bff;
            font-size: 1.1em;
        }

        .mensagem {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            color: #121213;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1001;
        }

        .mensagem.visivel {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Termo Ilimitado</h1>
        <p>ID do Jogo: <span id="currentId"></span></p>
        <p id="palavraRevelada" style="font-weight: bold; color: #ffeb3b; min-height: 1.2em; margin-top: 5px;"></p>
    </div>

    <div class="tabuleiro-container">
        <div class="tabuleiro" id="tabuleiro">
        </div>
    </div>

    <div class="controles">
        <div class="controles-linha-1">
            <button id="novoJogoBtn" class="primary">Novo Jogo Aleat√≥rio</button>
            <button id="compartilharBtn">Compartilhar ID</button>
        </div>
        <div class="controles-linha-2">
            <input type="number" id="palavraIdInput" placeholder="ID (1-9999)" min="1" max="9999">
            <button id="carregarIdBtn" class="primary">Carregar Jogo por ID</button>
        </div>
    </div>

    <div class="teclado-fixed" id="teclado">
    </div>

    <div class="mensagem" id="mensagem"></div>

    <script>
        // --- CONFIGURA√á√ÉO DO JOGO ---
        const PALAVRAS = [
            "sagaz", "expor", "assaz", "plena", "mutuo", "ceder", "citar", "anexo", "etnia", "valer",
            "vazio", "aferr", "genio", "icone", "fazer", "sendo", "desde", "poder", "mundo", "texto",
            "carro", "livro", "dente", "chave", "ponte", "beber", "comer", "andar", "luzir", "vozes",
            "grito", "roupa", "trigo", "chuva", "praia", "astro", "cabra", "noite", "massa", "terra"
        ];
        // ADICIONADO: Lista de todas as palavras v√°lidas que podem ser submetidas
        const PALAVRAS_VALIDAS = [
            "sagaz", "expor", "assaz", "plena", "mutuo", "ceder", "citar", "anexo", "etnia", "valer",
            "vazio", "aferr", "genio", "icone", "fazer", "sendo", "desde", "poder", "mundo", "texto",
            "carro", "livro", "dente", "chave", "ponte", "beber", "comer", "andar", "luzir", "vozes",
            "grito", "roupa", "trigo", "chuva", "praia", "astro", "cabra", "noite", "massa", "terra",
            // Adicione mais palavras v√°lidas aqui. Ex:
            "aonde", "caber", "obter", "cuidar", "falar", "dizer", "busca", "lugar", "coisa", "nunca"
            // ... complete com todas as 5-letras que voc√™ deseja permitir.
        ];
        const MAX_TENTATIVAS = 6;
        const TAMANHO_PALAVRA = 5;
        const MAX_ID_NUMERICO = 9999;

        // --- ESTADO DO JOGO ---
        let palavraSecreta = "";
        let tentativas = [];
        let linhaAtual = 0;
        let letraAtual = 0; // Posi√ß√£o do cursor/letra sendo editada (0 a 4)
        let jogoFinalizado = false;
        let idNumericoAtual = null;

        const tabuleiroEl = document.getElementById('tabuleiro');
        const tecladoEl = document.getElementById('teclado');
        const novoJogoBtn = document.getElementById('novoJogoBtn');
        const compartilharBtn = document.getElementById('compartilharBtn');
        const carregarIdBtn = document.getElementById('carregarIdBtn');
        const palavraIdInput = document.getElementById('palavraIdInput');
        const mensagemEl = document.getElementById('mensagem');
        const currentIdEl = document.getElementById('currentId');
        // NOVO: Refer√™ncia ao elemento que exibir√° a palavra
        const palavraReveladaEl = document.getElementById('palavraRevelada');

        palavraIdInput.setAttribute('inputmode', 'numeric');

        // --- FUN√á√ïES DE UTILIDADE E ID NUM√âRICO ---

        function obterIndiceDaPalavra(id) {
            return (id % PALAVRAS.length);
        }

        function gerarIdAleatorio() {
            return Math.floor(Math.random() * MAX_ID_NUMERICO) + 1;
        }

        function iniciarNovoJogo(id = null) {
            let idNum;

            if (id && !isNaN(id) && id >= 1 && id <= MAX_ID_NUMERICO) {
                idNum = parseInt(id);
            } else {
                idNum = gerarIdAleatorio();
            }

            idNumericoAtual = idNum;
            const indice = obterIndiceDaPalavra(idNum);
            palavraSecreta = PALAVRAS[indice];

            tentativas = [];
            linhaAtual = 0;
            letraAtual = 0;
            jogoFinalizado = false;

            currentIdEl.textContent = idNumericoAtual.toString().padStart(4, '0');
            document.title = `Termo Ilimitado - ID ${idNumericoAtual}`;

            // NOVO: Assume que a palavra deve estar oculta no in√≠cio
            ocultarPalavraSecreta();

            carregarEstadoDoLocalStorage();

            desenharTabuleiro();

            if (tecladoEl.children.length === 0) {
                desenharTeclado();
            } else {
                atualizarTecladoAposCarregamento();
            }

            posicionarCursor();

            if (tentativas.length > 0) {
                if (tentativas.includes(palavraSecreta)) {
                    jogoFinalizado = true;
                    mostrarPalavraSecreta(); // EXIBE se j√° ganhou
                    mostrarMensagem("Voc√™ j√° acertou esta palavra!", 2000);
                } else if (tentativas.length === MAX_TENTATIVAS) {
                    jogoFinalizado = true;
                    mostrarPalavraSecreta(); // EXIBE se j√° perdeu
                    mostrarMensagem(`Fim de jogo! A palavra era: ${palavraSecreta.toUpperCase()}`, 3000);
                }
            }
        }
        function mostrarMensagem(texto, duracao = 1500) {
            mensagemEl.textContent = texto;
            mensagemEl.classList.add('visivel');
            setTimeout(() => {
                mensagemEl.classList.remove('visivel');
            }, duracao);
        }

        function salvarEstadoNoLocalStorage() {
            if (!idNumericoAtual) return;
            const estado = {
                palavra: palavraSecreta,
                tentativas: tentativas,
                linhaAtual: linhaAtual,
                jogoFinalizado: jogoFinalizado
            };
            localStorage.setItem(`termo-jogo-${idNumericoAtual}`, JSON.stringify(estado));
        }

        function carregarEstadoDoLocalStorage() {
            if (!idNumericoAtual) return;
            const estadoSalvo = localStorage.getItem(`termo-jogo-${idNumericoAtual}`);
            if (estadoSalvo) {
                const estado = JSON.parse(estadoSalvo);

                if (estado.palavra === palavraSecreta) {
                    palavraSecreta = estado.palavra;
                    tentativas = estado.tentativas;
                    linhaAtual = estado.linhaAtual;
                    jogoFinalizado = estado.jogoFinalizado;
                } else {
                    tentativas = [];
                }
            }
        }

        // --- FUN√á√ïES DE RENDERIZA√á√ÉO E CURSOR ---

        function removerAtivoDeTodasAsCelulas() {
            document.querySelectorAll('.celula.ativa').forEach(c => c.classList.remove('ativa'));
        }

        function posicionarCursor(forcarPosicao = null) {
            removerAtivoDeTodasAsCelulas();

            if (jogoFinalizado || linhaAtual >= MAX_TENTATIVAS) return;

            if (forcarPosicao !== null) {
                letraAtual = forcarPosicao;
            } else {
                // Se n√£o for√ßada, move para a primeira c√©lula vazia da esquerda
                let palpite = tentativas[linhaAtual] || '';
                // Cria um array de 5 posi√ß√µes, preenchendo com espa√ßos para encontrar o √≠ndice vazio
                let palpitePreenchido = palpite.padEnd(TAMANHO_PALAVRA, ' ').split('');

                letraAtual = palpitePreenchido.findIndex(l => l.trim() === '');
                if (letraAtual === -1) {
                    letraAtual = TAMANHO_PALAVRA - 1; // Se estiver cheio, vai para a √∫ltima (para permitir apagar)
                }
            }

            // Garante que letraAtual est√° no limite
            letraAtual = Math.max(0, Math.min(letraAtual, TAMANHO_PALAVRA - 1));

            // Aplica a classe 'ativa'
            const linhaEl = tabuleiroEl.children[linhaAtual];
            if (linhaEl && linhaEl.children[letraAtual]) {
                linhaEl.children[letraAtual].classList.add('ativa');
            }
        }

        function lidarComCliqueNaCelula(linhaIndex, celulaIndex) {
            if (jogoFinalizado || linhaIndex !== linhaAtual) {
                return;
            }

            posicionarCursor(celulaIndex);
        }

        function desenharTabuleiro() {
            tabuleiroEl.innerHTML = '';
            for (let i = 0; i < MAX_TENTATIVAS; i++) {
                const linhaEl = document.createElement('div');
                linhaEl.className = 'linha';

                const palpite = tentativas[i] || '';
                // Garante que o palpite seja um array de 5 elementos (preenchidos ou vazios)
                let palpiteArray = palpite.padEnd(TAMANHO_PALAVRA, ' ').split('');

                for (let j = 0; j < TAMANHO_PALAVRA; j++) {
                    const celulaEl = document.createElement('div');
                    celulaEl.className = 'celula';
                    celulaEl.dataset.linha = i;
                    celulaEl.dataset.coluna = j;

                    const letra = palpiteArray[j].trim();

                    if (i < tentativas.length) {
                        // Linhas j√° finalizadas
                        celulaEl.textContent = letra.toUpperCase();
                        celulaEl.classList.add('preenchida');
                        const cor = obterCorDaLetra(palpite, j);
                        celulaEl.classList.add(cor);
                        celulaEl.style.cursor = 'default'; // N√£o clic√°vel
                    } else if (i === linhaAtual) {
                        // Linha atual (clic√°vel)
                        celulaEl.textContent = letra.toUpperCase();
                        if (letra) celulaEl.classList.add('preenchida');
                        celulaEl.addEventListener('click', () => lidarComCliqueNaCelula(i, j));
                    } else {
                        celulaEl.textContent = '';
                    }

                    linhaEl.appendChild(celulaEl);
                }
                tabuleiroEl.appendChild(linhaEl);
            }
        }

        function desenharTeclado() {
            tecladoEl.innerHTML = '';
            const layout = [
                "Q W E R T Y U I O P",
                "A S D F G H J K L",
                "ENTRAR Z X C V B N M APAGAR"
            ];

            layout.forEach(linha => {
                const linhaEl = document.createElement('div');
                linhaEl.className = 'linha-teclado';

                linha.split(' ').forEach(teclaTexto => {
                    const teclaEl = document.createElement('div');
                    teclaEl.className = 'tecla';

                    if (teclaTexto === 'ENTRAR') {
                        teclaEl.classList.add('tecla-entrar');
                        teclaEl.textContent = 'ENTRAR';
                    } else if (teclaTexto === 'APAGAR') {
                        teclaEl.classList.add('tecla-apagar');
                        teclaEl.textContent = '‚å´';
                    } else {
                        teclaEl.textContent = teclaTexto;
                    }

                    teclaEl.dataset.key = teclaTexto.toLowerCase();
                    teclaEl.addEventListener('click', () => processarEntrada(teclaTexto));
                    linhaEl.appendChild(teclaEl);
                });
                tecladoEl.appendChild(linhaEl);
            });
            atualizarCoresDoTeclado();
        }

        function atualizarCoresDoTeclado() {
            const statusLetras = {};

            for (const palpite of tentativas) {
                for (let i = 0; i < palpite.length; i++) {
                    const letra = palpite[i];
                    const cor = obterCorDaLetra(palpite, i);

                    if (cor === 'correta' || statusLetras[letra] === undefined) {
                        statusLetras[letra] = cor;
                    } else if (cor === 'presente' && statusLetras[letra] !== 'correta') {
                        statusLetras[letra] = cor;
                    } else if (cor === 'errada' && statusLetras[letra] !== 'correta' && statusLetras[letra] !== 'presente') {
                        statusLetras[letra] = cor;
                    }
                }
            }

            document.querySelectorAll('.tecla').forEach(tecla => {
                const letra = tecla.dataset.key;
                if (statusLetras[letra]) {
                    tecla.classList.remove('errada', 'presente', 'correta');
                    tecla.classList.add(statusLetras[letra]);
                } else if (tecla.textContent.length === 1 && tecla.textContent.match(/[A-Z]/)) {
                    tecla.classList.remove('errada', 'presente', 'correta');
                }
            });
        }

        function atualizarTecladoAposCarregamento() {
            desenharTabuleiro();
            atualizarCoresDoTeclado();
            posicionarCursor();
        }

        function obterCorDaLetra(palpite, index) {
            const letra = palpite[index];
            if (palavraSecreta[index] === letra) {
                return 'correta';
            }
            if (palavraSecreta.includes(letra)) {

                const mapaSecreta = {};
                for (const char of palavraSecreta) {
                    mapaSecreta[char] = (mapaSecreta[char] || 0) + 1;
                }

                let contagemAtual = 0;
                for (let i = 0; i < palpite.length; i++) {
                    if (palpite[i] === letra && palavraSecreta[i] === letra) {
                        contagemAtual++;
                    }
                }

                if (mapaSecreta[letra] > contagemAtual) {
                    let presentesUsadas = 0;
                    for (let i = 0; i < index; i++) {
                        if (palpite[i] === letra && obterCorDaLetra(palpite, i) === 'presente') {
                            presentesUsadas++;
                        }
                    }
                    if ((contagemAtual + presentesUsadas) < mapaSecreta[letra]) {
                        return 'presente';
                    }
                }

                return 'errada';
            }
            return 'errada';
        }

        // NOVO: Fun√ß√£o para exibir a palavra secreta no cabe√ßalho
        function mostrarPalavraSecreta() {
            palavraReveladaEl.textContent = `Palavra Secreta: ${palavraSecreta.toUpperCase()}`;
        }

        // NOVO: Fun√ß√£o para ocultar a palavra secreta
        function ocultarPalavraSecreta() {
            palavraReveladaEl.textContent = '';
        }

        // --- L√ìGICA DE ENTRADA CORRIGIDA ---
        // ...
        // --- L√ìGICA DE ENTRADA CORRIGIDA ---

        function processarEntrada(key) {
            if (jogoFinalizado) {
                mostrarMensagem(`O jogo j√° acabou! A palavra era: ${palavraSecreta.toUpperCase()}`, 2000);
                return;
            }

            key = key.toLowerCase();

            if (key === 'entrar') {
                lidarComEnter();
            } else if (key === 'apagar') {
                lidarComApagar();
            } else if (key.length === 1 && key >= 'a' && key <= 'z') {
                lidarComLetra(key);
            }

            salvarEstadoNoLocalStorage();
        }

        // --- L√ìGICA DE ENTRADA CORRIGIDA ---
        // ...
        function lidarComLetra(letra) {

            if (!tentativas[linhaAtual]) {
                tentativas[linhaAtual] = '';
            }

            // 1. Preenche o palpite com espa√ßos (para garantir 5 posi√ß√µes) e atualiza a letra na posi√ß√£o do cursor
            let palpiteArray = tentativas[linhaAtual].padEnd(TAMANHO_PALAVRA, ' ').split('');
            palpiteArray[letraAtual] = letra;

            // Salva o palpite garantindo 5 letras se estiver cheio (sem trimEnd)
            tentativas[linhaAtual] = palpiteArray.join('').trimEnd();
            // Garante que se estiver cheio (5 letras), a string salva tenha 5 caracteres exatos
            if (palpiteArray.every(l => l.trim() !== '')) {
                tentativas[linhaAtual] = palpiteArray.join('');
            }

            // 2. Atualiza a c√©lula no DOM
            const celula = tabuleiroEl.children[linhaAtual].children[letraAtual];
            celula.textContent = letra.toUpperCase();
            celula.classList.add('preenchida');

            // 3. MOVIMENTO CORRIGIDO: Procura a pr√≥xima c√©lula vazia ap√≥s a posi√ß√£o atual
            let proximoIndiceVazio = -1;
            for (let i = letraAtual + 1; i < TAMANHO_PALAVRA; i++) {
                if (palpiteArray[i].trim() === '') {
                    proximoIndiceVazio = i;
                    break;
                }
            }

            if (proximoIndiceVazio !== -1) {
                posicionarCursor(proximoIndiceVazio);
            } else if (letraAtual < TAMANHO_PALAVRA - 1 && palpiteArray.every(l => l.trim() !== '')) {
                // Se a palavra ficou cheia, mas ainda n√£o est√° na √∫ltima posi√ß√£o, move para a √∫ltima
                posicionarCursor(TAMANHO_PALAVRA - 1);
            } else {
                posicionarCursor(letraAtual); // Fica na √∫ltima c√©lula (se estiver cheia) ou onde est√°
            }
        }
        // CORRIGIDO: L√≥gica de apagar revisada para ser mais robusta.
        function lidarComApagar() {
            let palpite = tentativas[linhaAtual] || '';
            let palpiteArray = palpite.padEnd(TAMANHO_PALAVRA, ' ').split('');
            let posApagar = letraAtual;

            // Se o cursor estiver numa posi√ß√£o vazia (e n√£o for a 0), move para tr√°s para apagar a letra anterior
            if (palpiteArray[posApagar].trim() === '' && posApagar > 0) {
                posApagar = letraAtual - 1;
            } else if (palpiteArray[posApagar].trim() === '' && posApagar === 0) {
                return; // Linha vazia, nada para apagar
            }

            // Verifica se a posi√ß√£o de apagar tem conte√∫do (ap√≥s as checagens acima)
            if (palpiteArray[posApagar].trim() !== '') {
                // 1. Limpa a letra no palpite
                palpiteArray[posApagar] = ' ';

                // 2. Limpa a c√©lula no DOM
                const celula = tabuleiroEl.children[linhaAtual].children[posApagar];
                celula.textContent = '';
                celula.classList.remove('preenchida');

                // 3. Salva o palpite (removendo espa√ßos finais, se houver)
                tentativas[linhaAtual] = palpiteArray.join('').trimEnd();

                // 4. Move o cursor para a posi√ß√£o que acabou de ser apagada
                posicionarCursor(posApagar);

            } else {
                // Se a c√©lula atual estiver vazia, e n√£o for a 0, move o cursor para tr√°s (apenas movimento)
                if (letraAtual > 0) {
                    posicionarCursor(letraAtual - 1);
                }
            }
        }

        // --- L√ìGICA DE ENTRADA CORRIGIDA ---
        function lidarComEnter() {
            const palpite = tentativas[linhaAtual] || '';

            // 1. Valida√ß√£o de Preenchimento
            let palpitePreenchido = true;
            if (palpite.length < TAMANHO_PALAVRA) {
                palpitePreenchido = false;
            } else {
                // Verifica se h√° espa√ßos (vazios) dentro da string de palpite
                if (palpite.includes(' ')) {
                    palpitePreenchido = false;
                }
            }

            if (!palpitePreenchido) {
                mostrarMensagem("Preencha todas as 5 letras.", 1000);
                return;
            }

            // 2. Valida√ß√£o de Palavra Existente (NOVO!)
            const palpiteLowerCase = palpite.toLowerCase();

            // Verifica se a palavra est√° na lista de palavras secretas OU na lista de palavras v√°lidas
            if (palpiteLowerCase !== palavraSecreta.toLowerCase() && !PALAVRAS_VALIDAS.includes(palpiteLowerCase)) {
                mostrarMensagem("Palavra n√£o reconhecida ou inv√°lida.", 1500);
                return;
            }

            removerAtivoDeTodasAsCelulas();

            const palpiteLinhaEl = tabuleiroEl.children[linhaAtual];
            const mapaSecreta = {};
            for (const letra of palavraSecreta) {
                mapaSecreta[letra] = (mapaSecreta[letra] || 0) + 1;
            }

            const palpiteCorreto = new Array(TAMANHO_PALAVRA).fill(null);

            // 3. Fase: Verifica Corretas
            for (let i = 0; i < TAMANHO_PALAVRA; i++) {
                const letra = palpite[i];
                if (palavraSecreta[i] === letra) {
                    palpiteCorreto[i] = 'correta';
                    mapaSecreta[letra]--;
                    palpiteLinhaEl.children[i].classList.remove('ativa');
                    palpiteLinhaEl.children[i].classList.add('correta');
                }
            }

            // 4. Fase: Verifica Presentes e Erradas
            for (let i = 0; i < TAMANHO_PALAVRA; i++) {
                if (palpiteCorreto[i] === 'correta') continue;

                const letra = palpite[i];
                const celulaEl = palpiteLinhaEl.children[i];

                if (mapaSecreta[letra] && mapaSecreta[letra] > 0) {
                    celulaEl.classList.remove('ativa');
                    celulaEl.classList.add('presente');
                    mapaSecreta[letra]--;
                } else {
                    celulaEl.classList.remove('ativa');
                    celulaEl.classList.add('errada');
                }
            }

            atualizarCoresDoTeclado();

            // 5. Verifica se ganhou
            if (palpite === palavraSecreta) {
                jogoFinalizado = true;
                mostrarPalavraSecreta(); // NOVO: EXIBE A PALAVRA NO CABE√áALHO
                mostrarMensagem("üéâ Parab√©ns! Voc√™ acertou!", 3000);
                salvarEstadoNoLocalStorage();
                return;
            }

            // 6. Avan√ßa
            linhaAtual++;

            // 7. Verifica se perdeu
            if (linhaAtual >= MAX_TENTATIVAS) {
                jogoFinalizado = true;
                mostrarPalavraSecreta(); // NOVO: EXIBE A PALAVRA NO CABE√áALHO
                mostrarMensagem(`Fim de jogo! A palavra era: ${palavraSecreta.toUpperCase()}`, 4000);
                salvarEstadoNoLocalStorage();
            } else {
                desenharTabuleiro();
                posicionarCursor(0);
            }
        }

        novoJogoBtn.addEventListener('click', () => {
            if (tentativas.length > 0 && !jogoFinalizado) {
                if (!confirm("Tem certeza que deseja iniciar um novo jogo aleat√≥rio? O jogo atual ser√° perdido.")) {
                    return;
                }
            }
            if (idNumericoAtual) {
                localStorage.removeItem(`termo-jogo-${idNumericoAtual}`);
            }
            window.location.search = `?id=${gerarIdAleatorio()}`;
        });

        carregarIdBtn.addEventListener('click', () => {
            const idTexto = palavraIdInput.value.trim();
            const novoId = parseInt(idTexto);

            if (isNaN(novoId) || novoId < 1 || novoId > MAX_ID_NUMERICO) {
                mostrarMensagem(`O ID deve ser um n√∫mero entre 1 e ${MAX_ID_NUMERICO}.`, 1500);
                return;
            }

            window.location.search = `?id=${novoId}`;
        });

        compartilharBtn.addEventListener('click', () => {
            if (!idNumericoAtual) {
                mostrarMensagem("Nenhum jogo ativo para compartilhar.", 1500);
                return;
            }

            const urlCompartilhamento = `${window.location.origin}${window.location.pathname}?id=${idNumericoAtual}`;

            navigator.clipboard.writeText(urlCompartilhamento)
                .then(() => mostrarMensagem(`Link do Jogo (ID ${idNumericoAtual.toString().padStart(4, '0')}) Copiado! Envie para sua namorada.`, 2500))
                .catch(err => mostrarMensagem(`Erro ao copiar. Copie manualmente: ${urlCompartilhamento}`, 4000));
        });

        // --- INICIALIZA√á√ÉO ---

        function init() {
            const urlParams = new URLSearchParams(window.location.search);
            const idNaUrl = urlParams.get('id');

            if (idNaUrl) {
                const idNum = parseInt(idNaUrl);
                if (idNum >= 1 && idNum <= MAX_ID_NUMERICO) {
                    iniciarNovoJogo(idNum);
                } else {
                    iniciarNovoJogo(gerarIdAleatorio());
                }
            } else {
                iniciarNovoJogo(gerarIdAleatorio());
            }

            document.removeEventListener('keydown', lidarComTecladoFisico);
            document.addEventListener('keydown', lidarComTecladoFisico);
        }

        function lidarComTecladoFisico(e) {
            const key = e.key.toUpperCase();
            if (key === 'ENTER') {
                processarEntrada('ENTRAR');
                e.preventDefault();
            } else if (key === 'BACKSPACE') {
                lidarComApagar();
                e.preventDefault();
            } else if (key.length === 1 && key >= 'A' && key <= 'Z') {
                processarEntrada(key);
                e.preventDefault();
            }
        }

        init();
    </script>
</body>

</html>
